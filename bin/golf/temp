Initialize variables using values you already have.

Instead of x=1, try to look for something that already equals 1.
For example, a function's return value: printf("..");x=0; -> x=!printf("..");. It's easiest with 0, because you can always negate, or when all you need is the right truth value (and don't care if it's 1 or 19).

(x+1)*(y-1)     ==>    -~x*~-y

Sum and Product of list
#!ruby -an
i=$F.map &:to_i
puts"#{i.reduce &:+} #{i.reduce &:*}"

Python ternary: a&&b||c

 - instead of !=

if a>0 and a<10 and a+b==4 and a+3<1:
Becomes
if all([a>0,a<10,a+b==4,a+3<1]):

if (a && (b || c)) {

}

instead of:

if (a) {
    if (b) {
        //Do Stuff
    } elseif (c) {
        //Do same stuff
    }
}


